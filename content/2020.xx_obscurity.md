Title:HTB: Obscurity
Date: xx-xx-2020 17:35
category:security
tags:security, boot2root, HTB, 
meta:security, boot2root, HTB, 

<img class="align-left" src="/media/2020.xx/obscurity_card.png" alt="Obscurity card" width="262">


This is a writeup about a retired HacktheBox machine:
[Obscurity](https://www.hackthebox.eu/home/machines/profile/219)
This box is classified as a medium machine. It was release on December the first
2019 by [clubby789](https://www.hackthebox.eu/home/users/profile/83743).
It implies 

<!-- PELICAN_END_SUMMARY -->

[TOC]

# Getting User

## Recon

We start with a `nmap` scan. Only port 22 (SSH) and port 8080 are open.

    :::text
    # Nmap 7.80 scan initiated Fri Dec  6 04:58:41 2019 as: nmap -sS -p- -oA nmap 10.10.10.168
    Nmap scan report for 10.10.10.168
    Host is up (0.091s latency).
    Not shown: 65531 filtered ports
    PORT     STATE  SERVICE
    22/tcp   open   ssh
    80/tcp   closed http
    8080/tcp open   http-proxy
    9000/tcp closed cslistener
    
    # Nmap done at Fri Dec  6 05:01:34 2019 -- 1 IP address (1 host up) scanned in 173.56 seconds

We run a service scan on this two ports, the second port is an HTTP server.

    :::text
    # Nmap 7.80 scan initiated Fri Dec  6 05:11:21 2019 as: nmap -sSV -p22,80,8080,9000 -oA service 10.10.10.168
    Nmap scan report for 10.10.10.168
    Host is up (0.092s latency).

    PORT     STATE  SERVICE    VERSION
    22/tcp   open   ssh        OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
    80/tcp   closed http
    8080/tcp open   http-proxy BadHTTPServer
    9000/tcp closed cslistener
    1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :
    SF-Port8080-TCP:V=7.80%I=7%D=12/6%Time=5DEA2950%P=x86_64-pc-linux-gnu%r(Ge
    SF:tRequest,10FC,"HTTP/1\.1\x20200\x20OK\nDate:\x20Fri,\x2006\x20Dec\x2020
    SF:19\x2010:12:29\nServer:\x20BadHTTPServer\nLast-Modified:\x20Fri,\x2006\
    SF:x20Dec\x202019\x2010:12:29\nContent-Length:\x204171\nContent-Type:\x20t
    SF:ext/html\nConnection:\x20Closed\n\n<!DOCTYPE\x20html>\n<html\x20lang=\"
    SF:en\">\n<head>\n\t<meta\x20charset=\"utf-8\">\n\t<title>0bscura</title>\
    SF:n\t<meta\x20http-equiv=\"X-UA-Compatible\"\x20content=\"IE=Edge\">\n\t<
    SF:meta\x20name=\"viewport\"\x20content=\"width=device-width,\x20initial-s
    SF:cale=1\">\n\t<meta\x20name=\"keywords\"\x20content=\"\">\n\t<meta\x20na
    SF:me=\"description\"\x20content=\"\">\n<!--\x20\nEasy\x20Profile\x20Templ
    SF:ate\nhttp://www\.templatemo\.com/tm-467-easy-profile\n-->\n\t<!--\x20st
    SF:ylesheet\x20css\x20-->\n\t<link\x20rel=\"stylesheet\"\x20href=\"css/boo
    SF:tstrap\.min\.css\">\n\t<link\x20rel=\"stylesheet\"\x20href=\"css/font-a
    SF:wesome\.min\.css\">\n\t<link\x20rel=\"stylesheet\"\x20href=\"css/templa
    SF:temo-blue\.css\">\n</head>\n<body\x20data-spy=\"scroll\"\x20data-target
    SF:=\"\.navbar-collapse\">\n\n<!--\x20preloader\x20section\x20-->\n<!--\n<
    SF:div\x20class=\"preloader\">\n\t<div\x20class=\"sk-spinner\x20sk-spinner
    SF:-wordpress\">\n")%r(HTTPOptions,10FC,"HTTP/1\.1\x20200\x20OK\nDate:\x20
    SF:Fri,\x2006\x20Dec\x202019\x2010:12:30\nServer:\x20BadHTTPServer\nLast-M
    SF:odified:\x20Fri,\x2006\x20Dec\x202019\x2010:12:30\nContent-Length:\x204
    SF:171\nContent-Type:\x20text/html\nConnection:\x20Closed\n\n<!DOCTYPE\x20
    SF:html>\n<html\x20lang=\"en\">\n<head>\n\t<meta\x20charset=\"utf-8\">\n\t
    SF:<title>0bscura</title>\n\t<meta\x20http-equiv=\"X-UA-Compatible\"\x20co
    SF:ntent=\"IE=Edge\">\n\t<meta\x20name=\"viewport\"\x20content=\"width=dev
    SF:ice-width,\x20initial-scale=1\">\n\t<meta\x20name=\"keywords\"\x20conte
    SF:nt=\"\">\n\t<meta\x20name=\"description\"\x20content=\"\">\n<!--\x20\nE
    SF:asy\x20Profile\x20Template\nhttp://www\.templatemo\.com/tm-467-easy-pro
    SF:file\n-->\n\t<!--\x20stylesheet\x20css\x20-->\n\t<link\x20rel=\"stylesh
    SF:eet\"\x20href=\"css/bootstrap\.min\.css\">\n\t<link\x20rel=\"stylesheet
    SF:\"\x20href=\"css/font-awesome\.min\.css\">\n\t<link\x20rel=\"stylesheet
    SF:\"\x20href=\"css/templatemo-blue\.css\">\n</head>\n<body\x20data-spy=\"
    SF:scroll\"\x20data-target=\"\.navbar-collapse\">\n\n<!--\x20preloader\x20
    SF:section\x20-->\n<!--\n<div\x20class=\"preloader\">\n\t<div\x20class=\"s
    SF:k-spinner\x20sk-spinner-wordpress\">\n");
    Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

    Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
    # Nmap done at Fri Dec  6 05:11:35 2019 -- 1 IP address (1 host up) scanned in 13.83 seconds

## Web

We take a look at the home page. A few sentences inform us that the web server
is a custom one and that its source code is in a python file inside the
development directory.

> Here at 0bscura, we take a unique approach to security: you can't be hacked
> if attackers don't know what software you're using!
>
> That's why our motto is 'security through obscurity'; we write all our own
> software from scratch, even the webserver this is running on! This means that
> no exploits can possibly exist for it, which means it's totally secure! 

> Development
> Server Dev
>
> Message to server devs: the current source code for the web server is in 'SuperSecureServer.py' in the secret development directory

We launch a `dirb` in order to find this secret development directory. But
nothing come up.

    :::text
    -----------------
    DIRB v2.22    
    By The Dark Raver
    -----------------

    OUTPUT_FILE: dirb
    START_TIME: Fri Dec  6 05:50:36 2019
    URL_BASE: http://10.10.10.168:8080/
    WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt

    -----------------

    GENERATED WORDS: 4612

    ---- Scanning URL: http://10.10.10.168:8080/ ----
    + http://10.10.10.168:8080/index.html (CODE:200|SIZE:4171)

    -----------------
    END_TIME: Fri Dec  6 06:06:25 2019
    DOWNLOADED: 4612 - FOUND: 1

We know that the folder will contain the `SuperSecureServer.py` file.
We fire up burp and load the following in our intruder.

    GET /§§/SuperSecureServer.py HTTP/1.1
    Host: 10.10.10.168:8080
    User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Connection: close
    Upgrade-Insecure-Requests: 1
    If-Modified-Since: Fri, 06 Dec 2019 14:51:43
    Cache-Control: max-age=0

We attack it in sniper mod using the `dirb` wordlist in
`/usr/share/dirb/wordlists/common.txt`.

We sort the result by response's size and found the `develop` directory.

![burp intruder](/media/2020.xx/obscurity_1.png)

We `wget` the code on our machine.


    :::python
    import socket
    import threading
    from datetime import datetime
    import sys
    import os
    import mimetypes
    import urllib.parse
    import subprocess

    respTemplate = """HTTP/1.1 {statusNum} {statusCode}
    Date: {dateSent}
    Server: {server}
    Last-Modified: {modified}
    Content-Length: {length}
    Content-Type: {contentType}
    Connection: {connectionType}

    {body}
    """
    DOC_ROOT = "DocRoot"

    CODES = {"200": "OK", 
            "304": "NOT MODIFIED",
            "400": "BAD REQUEST", "401": "UNAUTHORIZED", "403": "FORBIDDEN", "404": "NOT FOUND", 
            "500": "INTERNAL SERVER ERROR"}

    MIMES = {"txt": "text/plain", "css":"text/css", "html":"text/html", "png": "image/png", "jpg":"image/jpg", 
            "ttf":"application/octet-stream","otf":"application/octet-stream", "woff":"font/woff", "woff2": "font/woff2", 
            "js":"application/javascript","gz":"application/zip", "py":"text/plain", "map": "application/octet-stream"}


    class Response:
        def __init__(self, **kwargs):
            self.__dict__.update(kwargs)
            now = datetime.now()
            self.dateSent = self.modified = now.strftime("%a, %d %b %Y %H:%M:%S")
        def stringResponse(self):
            return respTemplate.format(**self.__dict__)

    class Request:
        def __init__(self, request):
            self.good = True
            try:
                request = self.parseRequest(request)
                self.method = request["method"]
                self.doc = request["doc"]
                self.vers = request["vers"]
                self.header = request["header"]
                self.body = request["body"]
            except:
                self.good = False

        def parseRequest(self, request):        
            req = request.strip("\r").split("\n")
            method,doc,vers = req[0].split(" ")
            header = req[1:-3]
            body = req[-1]
            headerDict = {}
            for param in header:
                pos = param.find(": ")
                key, val = param[:pos], param[pos+2:]
                headerDict.update({key: val})
            return {"method": method, "doc": doc, "vers": vers, "header": headerDict, "body": body}


    class Server:
        def __init__(self, host, port):    
            self.host = host
            self.port = port
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.sock.bind((self.host, self.port))

        def listen(self):
            self.sock.listen(5)
            while True:
                client, address = self.sock.accept()
                client.settimeout(60)
                threading.Thread(target = self.listenToClient,args = (client,address)).start()

        def listenToClient(self, client, address):
            size = 1024
            while True:
                try:
                    data = client.recv(size)
                    if data:
                        # Set the response to echo back the recieved data 
                        req = Request(data.decode())
                        self.handleRequest(req, client, address)
                        client.shutdown()
                        client.close()
                    else:
                        raise error('Client disconnected')
                except:
                    client.close()
                    return False
        
        def handleRequest(self, request, conn, address):
            if request.good:
#            try:
                    # print(str(request.method) + " " + str(request.doc), end=' ')
                    # print("from {0}".format(address[0]))
#            except Exception as e:
#                print(e)
                document = self.serveDoc(request.doc, DOC_ROOT)
                statusNum=document["status"]
            else:
                document = self.serveDoc("/errors/400.html", DOC_ROOT)
                statusNum="400"
            body = document["body"]
            
            statusCode=CODES[statusNum]
            dateSent = ""
            server = "BadHTTPServer"
            modified = ""
            length = len(body)
            contentType = document["mime"] # Try and identify MIME type from string
            connectionType = "Closed"


            resp = Response(
            statusNum=statusNum, statusCode=statusCode, 
            dateSent = dateSent, server = server, 
            modified = modified, length = length, 
            contentType = contentType, connectionType = connectionType, 
            body = body
            )

            data = resp.stringResponse()
            if not data:
                return -1
            conn.send(data.encode())
            return 0

        def serveDoc(self, path, docRoot):
            path = urllib.parse.unquote(path)
            try:
                info = "output = 'Document: {}'" # Keep the output for later debug
                exec(info.format(path)) # This is how you do string formatting, right?
                cwd = os.path.dirname(os.path.realpath(__file__))
                docRoot = os.path.join(cwd, docRoot)
                if path == "/":
                    path = "/index.html"
                requested = os.path.join(docRoot, path[1:])
                if os.path.isfile(requested):
                    mime = mimetypes.guess_type(requested)
                    mime = (mime if mime[0] != None else "text/html")
                    mime = MIMES[requested.split(".")[-1]]
                    try:
                        with open(requested, "r") as f:
                            data = f.read()
                    except:
                        with open(requested, "rb") as f:
                            data = f.read()
                    status = "200"
                else:
                    errorPage = os.path.join(docRoot, "errors", "404.html")
                    mime = "text/html"
                    with open(errorPage, "r") as f:
                        data = f.read().format(path)
                    status = "404"
            except Exception as e:
                print(e)
                errorPage = os.path.join(docRoot, "errors", "500.html")
                mime = "text/html"
                with open(errorPage, "r") as f:
                    data = f.read()
                status = "500"
            return {"body": data, "mime": mime, "status": status}


